import { MessageHandlerFn } from 'ipfs-core-types/src/pubsub';
import * as fs from 'fs';
import {
  addBootstrapAddr,
  addSwarmAddr,
  CollabswarmConfig,
  DEFAULT_CONFIG,
} from './collabswarm-config';
import { Collabswarm } from './collabswarm';
import { CollabswarmDocument } from './collabswarm-document';
import { CRDTProvider } from './crdt-provider';
import { SyncMessageSerializer } from './sync-message-serializer';
import { ChangesSerializer } from './changes-serializer';
import { AuthProvider } from './auth-provider';
import { ACLProvider } from './acl-provider';
import { KeychainProvider } from './keychain-provider';
import { LoadMessageSerializer } from './load-request-serializer';
import { CRDTChangeNode, crdtChangeNodeDeferred } from './crdt-change-node';

export const DEFAULT_NODE_CONFIG: CollabswarmConfig = {
  ipfs: {
    relay: {
      enabled: true, // enable circuit relay dialer and listener
      hop: {
        enabled: true, // enable circuit relay HOP (make this node a relay)
      },
    },
    config: {
      Addresses: {
        Swarm: [
          '/ip4/0.0.0.0/tcp/4003/ws',
          '/ip4/0.0.0.0/tcp/4001',
          '/ip6/::/tcp/4002',
        ],
      },
      Bootstrap: [],
    },
  },

  pubsubDocumentPrefix: '/document/',
  pubsubDocumentPublishPath: '/documents',
};

export class CollabswarmNode<
  DocType,
  ChangesType,
  ChangeFnType,
  PrivateKey,
  PublicKey,
  DocumentKey
> {
  private _swarm = new Collabswarm(
    this.nodeKey,
    this.nodePublicKey,
    this.provider,
    this.changesSerializer,
    this.syncMessageSerializer,
    this.loadMessageSerializer,
    this.authProvider,
    this.aclProvider,
    this.keychainProvider,
  );
  public get swarm(): Collabswarm<
    DocType,
    ChangesType,
    ChangeFnType,
    PrivateKey,
    PublicKey,
    DocumentKey
  > {
    return this._swarm;
  }

  private readonly _subscriptions = new Map<
    string,
    CollabswarmDocument<
      DocType,
      ChangesType,
      ChangeFnType,
      PrivateKey,
      PublicKey,
      DocumentKey
    >
  >();
  private readonly _seenCids = new Set<string>();

  private _docPublishHandler: MessageHandlerFn | null = null;

  constructor(
    private readonly nodeKey: PrivateKey,
    private readonly nodePublicKey: PublicKey,
    public readonly provider: CRDTProvider<DocType, ChangesType, ChangeFnType>,
    public readonly changesSerializer: ChangesSerializer<ChangesType>,
    public readonly syncMessageSerializer: SyncMessageSerializer<ChangesType>,
    public readonly loadMessageSerializer: LoadMessageSerializer,
    public readonly authProvider: AuthProvider<
      PrivateKey,
      PublicKey,
      DocumentKey
    >,
    private readonly aclProvider: ACLProvider<ChangesType, PublicKey>,
    private readonly keychainProvider: KeychainProvider<
      ChangesType,
      DocumentKey
    >,
    public readonly config: CollabswarmConfig = DEFAULT_NODE_CONFIG,
  ) {}

  private async _pinNewCIDs(cid: string, node: CRDTChangeNode<ChangesType>) {
    if (!this._seenCids.has(cid)) {
      // TODO: Handle this operation failing (retry).
      // TODO: Does this need to be converted to a `CID` from a string first?
      this.swarm.ipfsNode.pin.add(cid);
      this._seenCids.add(cid);
    }

    if (node.children === crdtChangeNodeDeferred) {
      throw new Error('Currently IPLD deferred nodes are not supported!');
    }

    const tasks: Promise<void>[] = [];
    if (node.children !== undefined) {
      for (const [childHash, childNode] of Object.entries(node.children)) {
        tasks.push(this._pinNewCIDs(childHash, childNode));
      }
    }
    await Promise.all(tasks);
  }

  // Start
  public async start() {
    await this.swarm.initialize(this.config);
    // console.log('Node Addresses:', this.swarm.ipfsInfo.addresses);
    const websocketAddress = this.swarm.ipfsInfo.addresses.find(
      (address: any) => address.toString().includes('/ws/'),
    );
    let clientConfig = DEFAULT_CONFIG;
    if (websocketAddress) {
      clientConfig = addBootstrapAddr(
        clientConfig,
        websocketAddress.toString(),
      );
    }
    // TODO: Make this automatically generated by webrtc-star-signal (and integrate that into this).
    const starSignalAddress = '/ip4/127.0.0.1/tcp/9090/wss/p2p-webrtc-star';
    if (starSignalAddress) {
      clientConfig = addSwarmAddr(clientConfig, starSignalAddress.toString());
    }
    const clientConfigFile =
      process.env.REACT_APP_CLIENT_CONFIG_FILE || 'client-config.env';
    fs.writeFile(
      clientConfigFile,
      `REACT_APP_CLIENT_CONFIG='${JSON.stringify(clientConfig)}'`,
      (err: any) => {
        if (err) {
          console.error(`Failed to write ${clientConfigFile}:`, err);
        } else {
          console.log(`Wrote ${clientConfigFile}:`, clientConfig);
        }
      },
    );

    // Open a pubsub channel (set by some config) for controlling this swarm of listeners.
    // TODO: Add a '/document/<id>' prefix to all "normal" document paths.
    this._docPublishHandler = (rawMessage) => {
      try {
        const thisNodeId = this.swarm.ipfsInfo.id.toString();
        const senderNodeId = rawMessage.from;

        if (thisNodeId !== senderNodeId) {
          const message = this.syncMessageSerializer.deserializeSyncMessage(
            rawMessage.data,
          );
          console.log('Received Document Publish message:', rawMessage);
          const docRef = this.swarm.doc(message.documentId);

          if (docRef) {
            // Also add a subscription that pins new received files.
            this._subscriptions.set(message.documentId, docRef);
            docRef.subscribe('pinning-handler', (doc, hashes) => {
              for (const cid of hashes) {
                if (!this._seenCids.has(cid)) {
                  // TODO: Handle this operation failing (retry).
                  this.swarm.ipfsNode.pin.add(cid);
                  this._seenCids.add(cid);
                }
              }
            });

            // Listen to the file.
            docRef.open();

            // Pin all of the files that were received.
            if (message.changeId && message.changes) {
              this._pinNewCIDs(message.changeId, message.changes);
            }
          } else {
            console.warn(
              'Failed to process incoming document pin message:',
              rawMessage,
            );
            console.warn('Unable to load document', message.documentId);
          }
        } else {
          console.log('Skipping publish message from this node...');
        }
      } catch (err) {
        console.error(
          'Failed to process incoming document pin message:',
          rawMessage,
        );
        console.error('Error:', err);
      }
    };
    await this.swarm.ipfsNode.pubsub.subscribe(
      this.config.pubsubDocumentPublishPath,
      this._docPublishHandler,
    );
    console.log(
      `Listening for pinning requests on: ${this.config.pubsubDocumentPublishPath}`,
    );
  }

  public stop() {
    if (this._docPublishHandler) {
      this.swarm.ipfsNode.pubsub.unsubscribe(
        this.config.pubsubDocumentPublishPath,
        this._docPublishHandler,
      );
    }
    if (this._subscriptions) {
      for (const [id, ref] of this._subscriptions) {
        ref.unsubscribe('pinning-handler');
      }
    }
  }
}
